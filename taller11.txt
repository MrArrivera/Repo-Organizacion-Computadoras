section .data
    msg db "Resultado: ", 0
    len equ $ - msg

    errorMsg db "Error: division entre 0", 10, 0
    lenError equ $ - errorMsg

    newline db 10, 0
    lenNL equ $ - newline

section .bss
    resultado resb 1

section .text
    global _start

_start:
    ; ============================
    ; Números hardcoded
    ; ============================
    mov al, '8'       ; primer número (ASCII)
    sub al, '0'       ; convertir a entero

    mov bl, '0'       ; segundo número (ASCII) <-- aquí prueba div/0
    sub bl, '0'       ; convertir a entero

    ; ============================
    ; Comprobar si BL == 0
    ; ============================
    cmp bl, 0
    je division_cero      ; si divisor es 0 → saltar

    ; ============================
    ; División AL / BL
    ; ============================
    xor ah, ah            ; limpiar AH antes de DIV
    div bl                ; división válida
    add al, '0'           ; convertir a ASCII
    mov [resultado], al
    jmp imprimir_resultado

; ============================
; MANEJO DE DIVISIÓN ENTRE 0
; ============================
division_cero:
    mov eax, 4
    mov ebx, 1
    mov ecx, errorMsg
    mov edx, lenError
    int 0x80

    jmp salir

; ============================
; IMPRIMIR RESULTADO NORMAL
; ============================
imprimir_resultado:
    ; Imprimir "Resultado: "
    mov eax, 4
    mov ebx, 1
    mov ecx, msg
    mov edx, len
    int 0x80

    ; Imprimir resultado
    mov eax, 4
    mov ebx, 1
    mov ecx, resultado
    mov edx, 1
    int 0x80

    ; Imprimir salto de línea
    mov eax, 4
    mov ebx, 1
    mov ecx, newline
    mov edx, lenNL
    int 0x80

; ============================
; SALIR
; ============================
salir:
    mov eax, 1
    xor ebx, ebx
    int 0x80
